import "@cadl-lang/rest";
// using Cadl.Rest;
using Cadl.Http;

@doc("Supported Cognitive Services endpoint (e.g., https://<resource-name>.api.cognitiveservices.azure.com).")
model Endpoint is string {}

@doc("The name of the project to use.")
model ProjectNameQueryParameter {
}

@doc("The name of the project to use.")
model ProjectNamePathParameter {
}

@doc("The name of the specific deployment of the project to use.")
model DeploymentNameQueryParameter {
}

@doc("The name of the specific deployment of the project to use.")
model DeploymentNamePathParameter {
}

model ListQueryParams {
	@doc("The maximum number of resources to return from the collection.")
	@query top?: int32;

	@doc("An offset into the collection of the first resource to be returned.")
	@query skip?: int32;

	@doc("The maximum number of resources to include in a single response.")
	@query maxpagesize?: int32;
}

@doc("Language of the text records. This is BCP-47 representation of a language. For example, use \"en\" for English; \"es\" for Spanish etc. If not set, use \"en\" for English as default.")
model Language {
}

@knownValues(StringIndexTypeKV)
model StringIndexType is string {}
enum StringIndexTypeKV {
	TextElements_v8,
	UnicodeCodePoint,
	Utf16CodeUnit,
}

@doc("Represents List of Question Answers.")
model AnswersResult {
	@doc("Represents Answer Result list.")
	answers?: KnowledgeBaseAnswer[];
}

@doc("Represents knowledge base answer.")
model KnowledgeBaseAnswer {
	@doc("List of questions associated with the answer.")
	questions?: string[];
	@doc("Answer text.")
	answer?: string;
	@doc("Answer confidence score, value ranges from 0 to 1.")
	confidenceScore?: float64;
	@doc("ID of the QnA result.")
	id?: int32;
	@doc("Source of QnA result.")
	source?: string;
	@doc("Metadata associated with the answer, useful to categorize or filter question answers.")
	metadata?: Map<string, string>;
	dialog?: KnowledgeBaseAnswerDialog;
	@doc("Answer span object of QnA with respect to user's question.")
	answerSpan?: AnswerSpan;
}

@doc("Dialog associated with Answer.")
model KnowledgeBaseAnswerDialog {
	@doc("To mark if a prompt is relevant only with a previous question or not. If true, do not include this QnA as search result for queries without context; otherwise, if false, ignores context and includes this QnA in search result.")
	isContextOnly?: boolean;
	@doc("List of prompts associated with the answer.")
	prompts?: KnowledgeBaseAnswerPrompt[];
}

@doc("Prompt for an answer.")
model KnowledgeBaseAnswerPrompt {
	@doc("Index of the prompt - used in ordering of the prompts.")
	displayOrder?: int32;
	@doc("QnA ID corresponding to the prompt.")
	qnaId?: int32;
	@doc("Text displayed to represent a follow up question prompt.")
	displayText?: string;
}

@doc("Answer span object of QnA.")
model AnswerSpan {
	@doc("Predicted text of answer span.")
	text?: string;
	@doc("Predicted score of answer span, value ranges from 0 to 1.")
	confidenceScore?: float64;
	@doc("The answer span offset from the start of answer.")
	offset?: int32;
	@doc("The length of the answer span.")
	length?: int32;
}

@knownValues(RankerKindKV)
model RankerKind is string {}
enum RankerKindKV {
	Default,
	QuestionOnly,
}

@doc("Parameters to query a knowledge base.")
model AnswersOptions {
	@doc("Exact QnA ID to fetch from the knowledge base, this field takes priority over question.")
	qnaId?: int32;
	@doc("User question to query against the knowledge base.")
	question?: string;
	@doc("Max number of answers to be returned for the question.")
	top?: int32;
	@doc("Unique identifier for the user.")
	userId?: string;
	@doc("Minimum threshold score for answers, value ranges from 0 to 1.")
	confidenceScoreThreshold?: float64;
	@doc("Context object with previous QnA's information.")
	context?: KnowledgeBaseAnswerContext;
	@doc("Type of ranker to be used.")
	rankerType?: RankerKind;
	@doc("Filter QnAs based on given metadata list and knowledge base sources.")
	filters?: QueryFilters;
	@doc("To configure Answer span prediction feature.")
	answerSpanRequest?: ShortAnswerOptions;
	@doc("(Optional) Flag to enable Query over Unstructured Sources.")
	includeUnstructuredSources?: boolean;
}

@doc("Context object with previous QnA's information.")
model KnowledgeBaseAnswerContext {
	@doc("Previous turn top answer result QnA ID.")
	previousQnaId: int32;
	@doc("Previous user query.")
	previousUserQuery?: string;
}

@doc("filters over knowledge base.")
model QueryFilters {
	metadataFilter?: MetadataFilter;
	sourceFilter?: SourceFilter;
	@doc("Logical operation used to join metadata filter with source filter.")
	logicalOperation?: LogicalOperationKind;
}

@doc("Find QnAs that are associated with the given list of metadata.")
model MetadataFilter {
	metadata?: MetadataRecord[];
	@doc("Operation used to join metadata filters.")
	logicalOperation?: LogicalOperationKind;
}

@doc("Object to provide the key value pair for each metadata.")
model MetadataRecord {
	@doc("Metadata Key from Metadata dictionary used in the QnA.")
	key: string;
	@doc("Metadata Value from Metadata dictionary used in the QnA.")
	value: string;
}

@doc("Find QnAs that are associated with any of the given list of sources in knowledge base.")
model SourceFilter {
}

@knownValues(LogicalOperationKindKV)
model LogicalOperationKind is string {}
enum LogicalOperationKindKV {
	AND,
	OR,
}

enum enable {
	True,
}

@doc("To configure Answer span prediction feature.")
model ShortAnswerOptions {
	@doc("Enable or disable Answer Span prediction.")
	enable: enable;
	@doc("Minimum threshold score required to include an answer span, value ranges from 0 to 1.")
	confidenceScoreThreshold?: float64;
	@doc("Number of Top answers to be considered for span prediction from 1 to 10.")
	topAnswersWithSpan?: int32;
}

